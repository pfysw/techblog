如果是A->(B->C)型，先假设A,~(B->C)，由此推出B和~C，对~C反复操作后再代入A

如果是A->~(B->C)型，先假设A，再推出B和~C，再推出~(B->C)

公式：<br>
A>>B = A>((B>1)>2)<br>
(1>(1>2))>((A>1)>2) = A<br>
(A+B)>>L = A+(B>L);

关键问题在于mp不原子

找出一个定理的所有mp合成方法

命题的最简形式

化简方法，用等价方法去掉双重否定：((A->((~B->C)->D)) -> (A->(~~B->D)))

Sqlite大批量导入数据提高效率的几种方式
https://www.cnblogs.com/HPAHPA/articles/7662268.html
SQLite Backup API
https://cloud.tencent.com/developer/section/1420048
http://www.cnblogs.com/stephen-liu74/archive/2012/02/27/2326309.html
sqlite In-Memory Databases
https://cloud.tencent.com/developer/section/1420011
sqlite 内存数据库的attach
https://blog.csdn.net/striving1234/article/details/72845917
SQLite3 C语言API使用说明
https://blog.csdn.net/zgrjkflmkyc/article/details/45150951
rtree
https://blog.csdn.net/wzf1993/article/details/79547037
mmap使用细节
https://blog.csdn.net/bbzhaohui/article/details/81665370
https://www.cnblogs.com/hehehaha/archive/2013/03/14/6332946.html
windows查看磁盘扇区命令
fsutil fsinfo ntfsinfo c:
stackoverflow
https://itranslater.com/
https://www.soinside.com/
OpenGL进行简单的通用计算实例
https://www.cnblogs.com/riddick/p/6885680.html
视频
https://blog.csdn.net/qq_36449541/article/details/81485022
https://blog.csdn.net/leixiaohua1020/article/details/18893769#comments
H.264图像编码基础知识以及专业词语
https://blog.csdn.net/weixin_37921201/article/details/88982219

1.形变特征
2.存在消元
3.分解递归

在应用程序中替换Linux中Glibc的malloc的四种方法
https://blog.csdn.net/littlefang/article/details/6052563

关键是寻找一个更好的表达形式，那么表达形式能否自动生成
学会了的意思是把这个东西在脑子里组成一个特定的结构
先学习各种结构，然后融会贯通
把自己的思考过程提取成代码
先找到结构的框架边界，再往框架里填东西，各种各样的框架。

GLFW与Vulkan
https://www.cnblogs.com/bitzhuwei/archive/2019/06/22/11067313.html
glew工作原理
https://blog.csdn.net/u011760195/article/details/101483995?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.control
glew和glfw区别
https://blog.csdn.net/qq_15267341/article/details/83305856?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.control
glfw
http://ogldev.atspace.co.uk/

把结构层次化后才能更好的运用递归

A B C E F G按顺序排列，把在C左边的元素A和B放在bitmap里，这时候在C和E之前插入D，D左边元素的bitmap是由C的bitmap加上C元素组成的

层次化的内存分配
似乎只要到达某个点，就可以做到全自动化（不断拟合结构来递归

动态链接库dlopen等函数的使用
https://blog.csdn.net/qq_22122811/article/details/52590182

批处理：start /wait xxx.exe 等待程序执行结束

geany插件开发
https://www.geany.org/manual/reference/howto.html

moba、ahk、Pulover's Macro Creator

自己编译OpenGL项目踩过的坑
https://www.cnblogs.com/wulc/p/11627778.html

gtk的界面加上opengl
https://blog.csdn.net/Since_lily/article/details/86706969
从网上下了glew包，然后把glew32.dll放在C:\Windows\SysWOW64，编译-lglew32 -lglu32 -lopengl32，无法通过，glu.h里面要添加#define CALLBACK。解决后，又有一个问题找不到-lglew32，把glew32.dll放在D:\msys64\mingw64\lib就可以编译通过，运行时找不到glew32.dll，msys不识别C:\Windows\SysWOW64（因为这是vs的），然后添加环境变量D:\msys64\usr\lib（之前脑子晕了，把mingw64\lib当成了\usr\lib），然后还是找不到glew32.dll，然后以为还需要glew32.lib（其实不需要的，这个是vs用的），把glew32.dll放在D:\msys64\usr\lib就可以了，环境变量设的哪里，dll就放哪里

gtk的demo里有opengl，是基于libepoxy

用Eclipse写Shader？ 今天看到了一个神器，Synthclipse。
http://blog.jmecn.net/synthclipse/

Linux下的调试工具strace与ltrace
https://imsoul.blog.csdn.net/article/details/83143290?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-5.control

1.子结构包含子结构
2.中间结果溯源
3.逆向无回环路径
4.边界轮廓递归分解

QT OpenGL绘制三维图形（立方体、圆柱体、圆锥、球体、圆环等等）
https://www.cnblogs.com/MakeView660/p/10436685.html
qt opengl 3d基本形状圆锥
https://blog.csdn.net/wanghualin033/article/details/83552042

HS规则的代码实现和MP是同一个层次，但HS也可以由MP合成
有些硬件乘法器和加法器在电路上是同一个层次，但乘法也可以由加法合成。

PoinData的LineData再封装一层，用来表示线段
三角形中线交于一点，中点、3等分点、5等分点（素数等分点建立容器)

a|b b|c  a|c  素数的构造
递归的生成一个数据结构

linux：binutils工具集---as命令
Linux下两种汇编工具简单用法: NASM And AS
https://blog.csdn.net/qq_33528164/article/details/79515645

c语言文件定位：fseek()函数和ftell()函数的使用

Windows音频编程:Win32 Wave API 的使用
https://blog.51cto.com/2339637/1354925

小循环与大循环

如何使用GCC生成动态库和静态库
https://www.cnblogs.com/postw/p/9670791.html

Makefile常用调试方法
https://www.cnblogs.com/lotgu/p/5936465.html
make 调试命令
https://blog.csdn.net/carolzhang8406/article/details/55505836
shell脚本调试之工具——bashdb
https://www.cnblogs.com/itcomputer/p/5011845.html

sqlite3的3.31的testfixture.exe编译比较慢的原因是把所有的.c都重新编译一遍，
并没有中间的.o文件，tclsqlite3.exe的编译是正常的，参考下怎么做

对于{A命题集合}->{B命题集合}构成的大命题，有没有什么好的推理方法构建已经论证过的命题之间的联系，进而建立{A大命题集合}->{B大命题集合}的大大命题

用C语言实现修改注册表RegCreateKeyEx  RegSetValueEx
https://zhidao.baidu.com/question/156753542.html
右键快捷键
HKEY_CLASSES_ROOT\Directory\Background\shell
新增command项设置
D:\msys64\msys2_shell.cmd -mingw64 -here

把共性抽出来

怎么查看.a静态库所有打包进去的.o文件和函数接口信息？使用nm命令
https://blog.csdn.net/h_o_w_e/article/details/50995824

结构完全一样，只是所在层次不一样
先做出来，然后再抽出共同的点
层次结构越高，挂的信息也越多
静态符号通过动态过程来生成，动态过程又反过来通过静态符号来表示
概念生成的先后顺序，完备性定理的证明，方程思想

不要太执着于概念的本源，目标是把复杂的过程等价变换成简单的，已经很
简单的就不要去追究了，比如ax=0且x≠0，那么可以就直接得出a=0

gdb之watch命令
　　(gdb) rwatch 
　当expr被读时，停住程序。
　　(gdb) awatch 
　当expr被读或被写时，停住程序。
https://www.cnblogs.com/tekkaman/p/3506169.html

有结构层次的场景不能使用暴力搜索，需要先探寻结构是怎么组成的
(x1,x2)用（（1，0）（0，1））表示

相似结构归为一类
根据已有的结论避免不必要的搜索
通过解方程的思想确认未知的棋（如何通过行棋来帮助更好的解方程
通过悔棋回溯的方式来提升棋力
敌方是怎么看待自己的棋的
未明时变子

如何反复利用已有的结论
怎么把数理逻辑的结构套在几何上，两个命题做mp时的结构补全能不能运用在画辅助线上
补全结构是要有依据的
怎么把过程抽象成一个个元素，然后再由已有的元素生成新的元素

提取音频：
cmd输入： ffmpeg -i 0.blv -f mp3 1.mp3 即可，1.mp3就是我要的音频了

点和交点是两个不同的概念，它们处在不同的层次，携带信息也不一样。

解方程
层次迭代
输出对输入归一化
结构变换
动静转换

先提取出局面，然后搜索这个局面相关的着法，并分析局面之间的演化关系
把到特定的局面看成一个元素，然后进行战略搜索
在处理多个不同的局面的推演时可能存在某个着法存在冲突，不能兼顾，只能选择一种

几何元素和命题公式应该是两种不同的组成方式
几何元素可以看出命题公式的原子元素，不能使用MP推理时用的代换法，但是通过这些几何元素和->组成复合的命题作为公理仍然是有意义的，这样就可以和命题逻辑的公理L1、L2、L3一起推理，这些公理本身没什么意义，却好像推理过程中的催化剂一样。
有没有a->(b->c)型的公理或定理
定理(A->B)->((B->C)->(A->C))与HS的联系
P(A)->((P(A)->P(B))->P(B))

以A、B、C及其组合作为命题常元
以x1、x2、x3作为命题变元
P是一个谓词，代笔是否是定理，以此构造一个谓词逻辑系统

师长下一步扛旗时，要救回来时只有2种方法，要么先于对方扛旗，要么处理掉师长，要处理掉师长搜索其他的着法是没有用的，主要搜索5线和下营的棋，如果没有那就没办法处理，有那么判断是不是大于等于师长或炸弹。

相等公理：
P(x1,x1)
P(x1,x2)->(P(x1,x1)->P(x2,x1))
A->A
(A->B)->((A->A)->(B->A))
这里的形式有点相似，如何统一成一种形式

谓词逻辑的连续多次mp相当于命题逻辑的形式代换
命题逻辑的正常推理序列可以转换成演绎推理序列

一旦出现了暴力搜索，就要首先思考结构上有没有什么问题，给定一个需要证明的A->B型命题，如何把已有的结论都用起来。

栈溢出攻击及防护方法简介
https://www.jianshu.com/p/47d484b9227e

虽然无法想象出整个软件的结构，但是要知道自己写的每一行代码都在为整体做贡献
如何自动寻找合适的结构来避免暴力搜索

PHP与Web页面交互
https://blog.csdn.net/Zhili_wang/article/details/80934687

能不能把条件组织成命题这样的二叉树结构，然后通过部分条件补全前件的全部条件
人脑对错误的反馈纠正机制好像特别值得学习。

把各种条件判断的排列组合用0和1表示，怎么转换成形式命题进行统一处理。
对于不同的方向分支尽量把结构对齐进行统一处理

如何构建出一个结构满足信息传递的要求
如何根据目标反馈对结构进行调整

现在有24个分支条件需要处理，如果用switch需要写24个case的代码，而且每个case里面要处理的逻辑可能搞混，但如果分成2*3*4种情况处理，也是24个分支，但是代码只需要写2+3+4=9种case

好像没有必要知道大脑的具体结构，只要能感知到大脑分析处理具体问题时的具体步骤就足够了

公理条件的输入怎么串成一个逻辑推理整体
如何构建个一个系统描述“什么样的输入产生什么样的输出”

dll相对路径:_declspec(dllexport)
dumpbin
关于MSYS2的一点经验
http://www.360doc.com/content/18/0406/16/9200790_743313529.shtml
Windows10下Qt程序打包发布 (与配置环境变量)
https://cloud.tencent.com/developer/article/1475690
改变隐式加载dll路径的方法(不修改环境变量)
https://bbs.csdn.net/topics/380035555
windows dll 和 Linux so 的异同
https://blog.csdn.net/hanxin1987216/article/details/4506800

对规则现状不满时，一般有一下几种选择
1.退出游戏
2.花精力研究规则，利用规则来获取最大利益
3.做一些事情迫使规则的改变（这个一般是互相伤害，收益很小，而且一个人的力量也不够
4.成为规则的制定者
最后一种收益最大困难也最大，而且涉及到的人越多产生的破坏性也越大。
但是一个人开发软件好像就没这些缺点了，
规则想怎么定就怎么定很简单，软件只是给自己用的也没什么破坏性。

结构体的多层复用
几何画板
https://www.geogebra.org/

外壳不变，里面的内容换掉
一个结点里存放着一个链表，这个链表索引着不同环路的下一个结点，这样的链表如果有多个可以再串连成一个链表
边调试边设计
通过追踪源头来理解一个概念的形成
结构体定义错误怎么弥补
把回调函数作为结构组成的一部分

调用GDB的call命令执行函数时要有返回值，否则可能会卡死